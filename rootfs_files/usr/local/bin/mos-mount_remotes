#!/bin/sh
PATH=$PATH:/usr/local/bin

# Get json and write it into variable
REMOTES_JSON="$(cat /boot/config/remotes.json 2>/dev/null)"
if [ -z "$1" ]; then
  REMOTES=$(echo "$REMOTES_JSON" | jq -r '.[] | .name' 2>/dev/null)
else
  REMOTES="$1"
fi

# Get JWT_SECRET from api to decrypt passwords
JWT_SECRET="$(cat /boot/config/api/env 2>/dev/null | grep 'JWT_SECRET' | cut -d '=' -f2)"

decrypt_password() {
  # Split password
  IFS=':' read -r IV_HEX AUTH_TAG_HEX ENCRYPTED_DATA <<< "$1"

  # Decrypt password using node
  node -e "
const crypto = require('crypto');

const algorithm = 'aes-256-gcm';
const key = crypto.scryptSync('$JWT_SECRET', 'remotes-salt', 32);
const iv = Buffer.from('$IV_HEX', 'hex');
const authTag = Buffer.from('$AUTH_TAG_HEX', 'hex');
const encrypted = '$ENCRYPTED_DATA';

try {
    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    decipher.setAuthTag(authTag);
    decipher.setAAD(Buffer.from('remotes-auth'));
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    console.log(decrypted);
} catch (error) {
    console.error('Decryption failed:', error.message);
    process.exit(1);
}"
}

# Ensure remotes directory exists
mkdir -p /mnt/remotes

IFS=$'\n'
for remote_name in $REMOTES; do
  # Extract remote json
  REMOTE_JSON=$(echo "$REMOTES_JSON" | jq -r ".[] | select(.name == \"$remote_name\")")
  REMOTE_AUTOMOUNT=$(echo "$REMOTE_JSON" | jq -r '.auto_mount')
  if [ "$REMOTE_AUTOMOUNT" = "true" ]; then
    # Extract values from JSON with default values for null
    type=$(echo "$REMOTE_JSON" | jq -r '.type')
    server=$(echo "$REMOTE_JSON" | jq -r '.server')
    share=$(echo "$REMOTE_JSON" | jq -r '.share')
    username=$(echo "$REMOTE_JSON" | jq -r '.username')
    password=$(echo "$REMOTE_JSON" | jq -r '.password')
    domain=$(echo "$REMOTE_JSON" | jq -r '.domain')
    version=$(echo "$REMOTE_JSON" | jq -r '.version // "3.0"')
    uid=$(echo "$REMOTE_JSON" | jq -r '.uid')
    gid=$(echo "$REMOTE_JSON" | jq -r '.gid')

    # Check if share path is already mounted
    if findmnt /mnt/remotes/${server}/${share} >/dev/null 2>&1 ; then
      logger "Already found mounted share at: /mnt/remotes/${server}/${share}, skipping"
      continue
    fi

    # Create share directory
    [ ! -d /mnt/remotes/${server}/${share} ] && \
      mkdir -p /mnt/remotes/${server}/${share}

    # Check if share is smb or nfs and mount remote share
    if [ "$type" = "smb" ] ; then
      if [ "$username" != "null" ] ; then
        DECRYPTED_PASSWORD=$(decrypt_password "${password}")
        SMB_OPTIONS="username=${username},password=${DECRYPTED_PASSWORD},vers=${version},iocharset=utf8,noperm"
        unset DECRYPTED_PASSWORD
      else
        SMB_OPTIONS="guest,vers=${version}"
      fi

      [ "$domain" != "null" ] && \
        SMB_OPTIONS="$SMB_OPTIONS,domain=${domain}"

      [ "$uid" != "null" ] && \
        SMB_OPTIONS="$SMB_OPTIONS,uid=${uid}"

      [ "$gid" != "null" ] && \
        SMB_OPTIONS="$SMB_OPTIONS,gid=${gid}"

      logger "Mounting SAMBA remote share: $share from host: $server"
      mount -t cifs //${server}/${share} /mnt/remotes/${server}/${share} -o ${SMB_OPTIONS}
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" != "0" ] ; then
        logger "Error mounting SAMBA share: $share from server: $server"
        rmdir /mnt/remotes/${server}/${share}
      fi
    elif [ "$type" = "nfs" ] ; then
      NFS_OPTIONS="vers=4,rsize=1048576,wsize=1048576,hard,intr,timeo=600"

      [ "$uid" != "null" ] && \
        NFS_OPTIONS="$NFS_OPTIONS,uid=${uid}"

      [ "$gid" != "null" ] && \
        NFS_OPTIONS="$NFS_OPTIONS,gid=${gid}"

      logger "Mounting NFS remote share: $share from host: $server"
      mount -t nfs ${server}:/${share} /mnt/remotes/${server}/${share} -o ${NFS_OPTIONS}
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" != "0" ] ; then
        logger "Error mounting NFS share: $share from server: $server"
        rmdir /mnt/remotes/${server}/${share}
      fi
    fi
  fi
done
