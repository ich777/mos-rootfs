#!/bin/sh

# Import MOS functions
. /usr/local/lib/functions/mos-common

# Check if argument was passed over (check single or all containers)
if [ -z "$1" ] ; then
  CONTAINER_UPDATES=()
  CONTAINERS_JSON=$(cat /var/lib/docker/mos/containers 2>/dev/null)
  CONTAINER_NAMES=$(echo $CONTAINERS_JSON | jq -r '.[].name')
  COMPOSE_JSON=$(cat /var/lib/docker/mos/compose-containers 2>/dev/null)
  COMPOSE_NAMES=$(echo $COMPOSE_JSON | jq -r '.[].services.[].container')
else
  CONTAINERS_JSON=$(cat /var/lib/docker/mos/containers 2>/dev/null)
  if echo $CONTAINERS_JSON | jq -e --arg name "$1" '.[] | select(.name == $name)' >/dev/null ; then
    CONTAINER_NAMES=$1
  else
    echo "Container $1 not in container list found"
    exit 1
  fi
fi

GH_TOKEN=$(jq -r '.github // empty' /boot/config/system/tokens.json)
DOCKER_TOKEN=$(jq -r '.dockerhub // empty' /boot/config/system/tokens.json)
if [ ! -z "$GH_TOKEN" ] ; then
  GHAUTH="-u _ -p $(decrypt_password "$GH_TOKEN" "tokens")"
else
  GHAUTH=""
fi
if [ ! -z "$DOCKER_TOKEN" ] ; then
  DOCKERUSERPW="$(decrypt_password "$DOCKER_TOKEN" "tokens")"
  DOCKERAUTH="-u ${DOCKERUSERPW%%:*} -p ${DOCKERUSERPW#*:}"
else
  DOCKERAUTH=""
fi

# Loop through docker containers
for container in $CONTAINER_NAMES
do
  # Get necessary infromations for check and if there is already a update available
  REPO=$(echo $CONTAINERS_JSON | jq -r --arg name "$container" '.[] | select(.name == $name) | .repo')
  LOCAL_SHA=$(echo $CONTAINERS_JSON | jq -r --arg name "$container" '.[] | select(.name == $name) | .local')
  REMOTE_SHA_OLD=$(echo $CONTAINERS_JSON | jq -r --arg name "$container" '.[] | select(.name == $name) | .remote')

  # Check if a tag is applied, if not add :latest
  if echo "$REPO" | grep -q ':' ; then
    IMAGE="$REPO"
  else
    IMAGE="$REPO:latest"
  fi

  # Get remote SHA
  case "$REPO" in
    ghcr.io*)
      REMOTE_SHA=$(image-sha $GHAUTH $IMAGE)
      ;;
    docker.io*|http*://docker.io*|index.docker.io*)
      REMOTE_SHA=$(image-sha $DOCKERAUTH $IMAGE)
      ;;
    http://*|https://*|localhost*|*.*/*|[0-9]*.[0-9]*)
      REMOTE_SHA=$(image-sha $IMAGE)
      ;;
    *)
      REMOTE_SHA=$(image-sha $DOCKERAUTH $IMAGE)    
      ;;
  esac

  REMOTE_SHA=$(echo "$REMOTE_SHA" | head -1)

  # Safety check if remote SHA is valid
  case "$REMOTE_SHA" in
    sha*)
      :
      ;;
    *)
      echo "ERROR: Error getting latest digest for container $container"
      ERROR=true
      continue
      ;;
  esac

  # Compare SHA values and inject new remote SHA to containers file
  if [ "$LOCAL_SHA" != "$REMOTE_SHA" ] ; then
    if [ "$REMOTE_SHA" != "$REMOTE_SHA_OLD" ] ; then
      jq --arg repo "$REPO" \
         --arg name "$container" \
         --arg local "$LOCAL_SHA" \
         --arg remote "$REMOTE_SHA" '
        map(
          if .repo == $repo and .name == $name then
            if .remote != $remote or .local != $local then
              .remote = $remote
              | .local = $local
            else
              .
            end
          else
            .
          end
        )
      ' /var/lib/docker/mos/containers > /var/lib/docker/mos/containers.tmp && mv /var/lib/docker/mos/containers.tmp /var/lib/docker/mos/containers
      echo "Update for $container found"
    else
      echo "Update for $container pending"
    fi
    CONTAINER_UPDATES+=("$container")
  else
    echo "Nothing to do for $container"
  fi
done

# Loop through compose containers
for container in $COMPOSE_NAMES
do
  # Get necessary infromations for check and if there is already a update available
  STACK=$(echo $COMPOSE_JSON | jq -r --arg name "$container" '.[] | select(.services[]?.container == $name) | .stack')
  REPO=$(echo $COMPOSE_JSON | jq -r --arg name "$container" '.[].services.[] | select(.container == $name) | .repo')
  LOCAL_SHA=$(echo $COMPOSE_JSON | jq -r --arg name "$container" '.[].services.[] | select(.container == $name) | .local')
  REMOTE_SHA_OLD=$(echo $COMPOSE_JSON | jq -r --arg name "$container" '.[].services.[] | select(.container == $name) | .remote')

  # Check if a tag is applied, if not add :latest
  if echo "$REPO" | grep -q ':' ; then
    IMAGE="$REPO"
  else
    IMAGE="$REPO:latest"
  fi

  # Get remote SHA
  case "$REPO" in
    ghcr.io*)
      REMOTE_SHA=$(image-sha $GHAUTH $IMAGE)
      ;;
    docker.io*|http*://docker.io*|index.docker.io*)
      REMOTE_SHA=$(image-sha $DOCKERAUTH $IMAGE)
      ;;
    http://*|https://*|localhost*|*.*/*|[0-9]*.[0-9]*)
      REMOTE_SHA=$(image-sha $IMAGE)
      ;;
    *)
      REMOTE_SHA=$(image-sha $DOCKERAUTH $IMAGE)    
      ;;
  esac

  REMOTE_SHA=$(echo "$REMOTE_SHA" | head -1)

  # Safety check if remote SHA is valid
  case "$REMOTE_SHA" in
    sha*)
      :
      ;;
    *)
      echo "ERROR: Error getting latest digest for compose container $container"
      ERROR=true
      continue
      ;;
  esac

  # Compare SHA values and inject new remote SHA to containers file
  if [ "$LOCAL_SHA" != "$REMOTE_SHA" ] ; then
    if [ "$REMOTE_SHA" != "$REMOTE_SHA_OLD" ] ; then
      jq --arg container "$container" \
         --arg local "$LOCAL_SHA" \
         --arg remote "$REMOTE_SHA" '
        map(
          .services |=
          with_entries(
            if .value.container == $container then
              .value.remote |= $remote
               | .value.local |= $local
            else
              .
            end
          )
        )
      ' /var/lib/docker/mos/compose-containers > /var/lib/docker/mos/compose-containers.tmp && mv /var/lib/docker/mos/compose-containers.tmp /var/lib/docker/mos/compose-containers
      echo "Update for $container from compose stack $STACK found"
    else
      echo "Update for $container from compose stack $STACK pending"
    fi
    CONTAINER_UPDATES+=("$container")
  else
    echo "Nothing to do for $container"
  fi
done

# Send notify if all container where checked which containers have updates available
if [ "$2" = "notification" ] ; then
  if [ -z "$1" ] ; then
    if [ ! -z "$CONTAINER_UPDATES" ] ; then
      MSG_UPDATES=$(IFS=','; echo "${CONTAINER_UPDATES[*]}")
      MSG_UPDATES=${MSG_UPDATES//,/,\ }
      if [ "$ERROR" = "true" ] ; then
        notify -t "Docker Update Check" -m "Updates for following containers available: $MSG_UPDATES, some digests could not be retrieved" -p "warning"
      else
        notify -t "Docker Update Check" -m "Updates for following containers available: $MSG_UPDATES" -p "normal"
      fi
    else
      if [ "$ERROR" = "true" ] ; then
        notify -t "Docker Update Check" -m "All containers checked, no updates found, some digests could not be retrieved" -p "warning"
      else
        notify -t "Docker Update Check" -m "All containers up to date" -p "normal"
      fi
    fi
  fi
else
  if [ -z "$1" ] ; then
    if [ ! -z "$CONTAINER_UPDATES" ] ; then
      MSG_UPDATES=$(IFS=','; echo "${CONTAINER_UPDATES[*]}")
      MSG_UPDATES=${MSG_UPDATES//,/,\ }
      if [ "$ERROR" = "true" ] ; then
        echo
        echo "Updates for following containers available: $MSG_UPDATES"
        echo "WARNING: Some digests could not be retrieved"
      else
        echo
        echo "Updates for following containers available: $MSG_UPDATES"
      fi
    else
      if [ "$ERROR" = "true" ] ; then
        echo
        echo "All containers checked, no updates found"
        echo "WARNING: Some digests could not be retrieved"
      else
        echo
        echo "All containers up to date"
      fi
    fi
  fi
fi

sync
