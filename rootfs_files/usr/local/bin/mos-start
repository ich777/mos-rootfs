#!/bin/sh
# Put all JSONs into Variables
SYSTEM_JSON=$(jq '.' /boot/config/system.json 2>/dev/null)
DOCKER_JSON=$(jq '.' /boot/config/docker.json 2>/dev/null)
LXC_JSON=$(jq '.' /boot/config/lxc.json 2>/dev/null)
VM_JSON=$(jq '.' /boot/config/vm.json 2>/dev/null)
NETWORK_JSON=$(jq '.' /boot/config/network.json 2>/dev/null)
HUB_JSON=$(jq '.' /boot/config/system/hub.json 2>/dev/null)
ZRAM_JSON=$(jq '.' /boot/config/system/zram.json 2>/dev/null)

# Execute echo to get one emty line
echo

# Execute sensors-detect
start_sensors_detect() {
  /etc/init.d/sensors start
}

# Execute start script if found
start_script() {
  if [ -f /boot/optional/scripts/pre-start.sh ] ; then
    cp /boot/optional/scripts/pre-start.sh /tmp/pre-start.sh
    chmod +x /tmp/pre-start.sh
    ( /tmp/pre-start.sh )
    rm -f /tmp/pre-start.sh
  fi
}

# Execute end script if found
end_script() {
  if [ -f /boot/optional/scripts/post-start.sh ] ; then
    cp /boot/optional/scripts/post-start.sh /tmp/post-start.sh
    chmod +x /tmp/post-start.sh
    ( /tmp/post-start.sh )
    rm -f /tmp/post-start.sh
  fi
}

# Write file to /run that MOS bootscript is done
write_run() {
  echo "Don't remove this file" > /run/mos-booted
}

# Start notify service
start_notify() {
  /etc/init.d/notify start
}

# Start smartmontools
start_smart() {
  /etc/init.d/smartmontools start
}

# Start cron service
start_cron() {
  /etc/init.d/cron start
}

# Start ssh service if enabled
start_ssh() {
  SSH_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.ssh.enabled')
  if [ "$SSH_ENABLED" = "true" ] ; then
    /etc/init.d/ssh start
  fi
}

# Start ntpd service if enabled
start_ntp() {
  NTP_ENABLED=$(echo $SYSTEM_JSON | jq -r '.ntp.enabled')
  if [ "$NTP_ENABLED" = "true" ] ; then
    /etc/init.d/ntpsec start
  fi
}

# Start nginx service for the WebUI
start_nginx() {
  /etc/init.d/nginx start
}

# Start MOS API service
start_api() {
  /etc/init.d/api start
}

# Mount disks
mount_disks() {
  /usr/local/bin/mos-mount_disks
}

# Start NUT UPS service if enabled
start_nut() {
  NUT_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.nut.enabled')
  if [ "$NUT_ENABLED" = "true" ] ; then
    /etc/init.d/nut-server start
    /etc/init.d/nut-client start
  fi
}

# Install optional .deb packages
optional_packages() {
  OPTIONAL_PACKAGES=$(ls -1 /boot/optional/packages/)
  if [ ! -z "$OPTIONAL_PACKAGES" ] ; then
    logger "Installing additional packages"
    for package in $OPTIONAL_PACKAGES
    do
      logger "Installing: $package"
      DEBIAN_FRONTEND=noninteractive dpkg -i /boot/optional/packages/$package >/dev/null 2>&1
    done
  fi
}

# Create Docker network interface for ipvlan/macvlan
docker_network_create() {
  DOCKER_NET_CONFIG=$(echo $DOCKER_JSON | jq -r '.docker_net.config')

  if [ "$(echo $DOCKER_NET_CONFIG | jq '. | length')" = "0" ] ; then
    DOCKER_SUBNET="$(ip route show dev $1 | awk '/src/ {print $1}')"
    DOCKER_GATEWAY="$(ip route show default 0.0.0.0/0 dev $1 | awk '{print $3}')"
  else
    DOCKER_SUBNET="$(echo $DOCKER_NET_CONFIG | jq -r '.[].subnet')"
    DOCKER_GATEWAY="$(echo $DOCKER_NET_CONFIG | jq -r '.[].gateway')"
  fi

  docker network create -d $2 \
  --subnet=$DOCKER_SUBNET \
  --gateway=$DOCKER_GATEWAY \
  -o parent=$1 \
  $1 >/dev/null 2>&1
}

# Check if Docker interface for ipvlan/macvlan is already in place
docker_network_check() {
  DOCKER_NET_MODE=$(echo $DOCKER_JSON | jq -r '.docker_net.mode')
  INTERFACE_MODE=$(echo $NETWORK_JSON | jq -r '.interfaces[] | select(.name == "eth0") | .type')
  if [ "$INTERFACE_MODE" = "bridged" ] ; then
    INTERFACE=br0
  else
    INTERFACE=eth0
  fi
  # Check for Docker networks where the parent is non existent
  if [ "$INTERFACE" = "br0" ] ; then
    if docker network inspect eth0 >/dev/null 2>&1; then
      docker network rm --force eth0 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  else
    if docker network inspect br0 >/dev/null 2>&1; then
      docker network rm --force br0 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  fi
  # Check for Docker networks with wrong net_mode
  if [ "$DOCKER_NET_MODE" = "ipvlan" ] ; then
    if [ "$(docker network inspect $1 >/dev/null 2>&1 | jq -r '.[].Driver')" = "macvlan" ] ; then
      docker network rm --force $1 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  elif [ "$DOCKER_NET_MODE" = "macvlan" ] ; then
    if [ "$(docker network inspect $1 >/dev/null 2>&1 | jq -r '.[].Driver')" = "ipvlan" ] ; then
      docker network rm --force $1 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  fi
  # Create Docker network if it not exists
  if ! docker network inspect $1 >/dev/null 2>&1; then
    docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
  fi
}

# Execute Docker autostart
docker_autostart() {
  /usr/local/bin/mos-docker_autostart >/dev/null 2>&1 &
}

# Start Docker service if enabled
start_docker() {
  DOCKER_ENABLED=$(echo $DOCKER_JSON | jq -r '.enabled')
  if [ "$DOCKER_ENABLED" = "true" ] ; then
    DOCKER_APPDATA=$(echo $DOCKER_JSON | jq -r '.appdata')
    DOCKER_OPTIONS=$(echo $DOCKER_JSON | jq -r '.docker_options // ""')
    if [ ! -d $DOCKER_APPDATA ] ; then
      mkdir -p $DOCKER_APPDATA
    fi
    DOCKER_OPTS="$DOCKER_OPTIONS" /etc/init.d/docker start
  fi
}


# Start LXC service if enabled (and lxc-net if enabled)
start_lxc() {
  LXC_ENABLED=$(echo $LXC_JSON | jq -r '.enabled')
  if [ "$LXC_ENABLED" = "true" ] ; then
    LXC_DIRECTORY=$(echo $LXC_JSON | jq -r '.directory')
    LXC_BRIDGE=$(echo $LXC_JSON | jq -r '.bridge')
    /etc/init.d/lxc "start" "$LXC_DIRECTORY"
    /usr/local/bin/mos-lxc_autostart >/dev/null 2>&1 &
    if [ "$LXC_BRIDGE" = "true" ]; then
      /etc/init.d/lxc-net start
    fi
  fi
}

# Start VM services if enabled
start_vm() {
  VM_ENABLED=$(echo $VM_JSON | jq -r '.enabled')
  if [ "$VM_ENABLED" = "true" ] ; then
    /etc/init.d/libvirtd start
    /etc/init.d/virtlogd start
  fi
}

# Start nmbd service if enabled (SAMBA Discovery)
start_nmbd() {
  NMBD_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.nmbd.enabled')
  if [ "$NMBD_ENABLED" = "true" ] ; then
    /etc/init.d/nmbd start
  fi
}

# Start SAMBA service if enabled
start_samba() {
  SAMBA_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.samba.enabled')
  if [ "$SAMBA_ENABLED" = "true" ] ; then
    /etc/init.d/smbd start
  fi
}

# Start NFS service if enabled
start_nfs() {
  NFS_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.nfs.enabled')
  if [ "$NFS_ENABLED" = "true" ] ; then
    /etc/init.d/nfs-kernel-server start
  fi
}

# Start Tailscale service if enabled
start_tailscale() {
  TAILSCALE_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.tailscale.enabled')
  if [ "$TAILSCALE_ENABLED" = "true" ] ; then
    /etc/init.d/tailscaled start
  fi
}

# Start Netbird service if enabled
start_netbird() {
  NETBIRD_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.netbird.enabled')
  if [ "$NETBIRD_ENABLED" = "true" ] ; then
    /etc/init.d/netbird start
  fi
}

# Execute scripts to set disk standby timeouts and start spindown watchdog for disks
mos_spindown() {
  DISKS=$(find /dev/ -name sd?)
  for disk in $DISKS
  do
    nohup /usr/local/bin/mos-set_spindown $disk >/dev/null 2>&1 &
    setsid /usr/local/bin/mos-spindown_watchdog $disk &>/dev/null < /dev/null &
  done
}

# Start iSCSI Target service if enabled
start_iscsi_target() {
  ISCSI_TARGET_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.iscsi_target.enabled')
  if [ "$ISCSI_TARGET_ENABLED" = "true" ] ; then
    /etc/init.d/tgt start
  fi
}


# Mount Remotes if remote_mounting is enabled
mount_remotes() {
  REMOTE_MOUNTS_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.remote_mounting.enabled')
  if [ "$REMOTE_MOUNTS_ENABLED" = "true" ] ; then
    /usr/local/bin/mos-mount_remotes &
  fi
}

# Start iSCSI Initiator service if enabled and mount Targets
start_iscsi_initiator() {
  ISCSI_INITIATOR_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.iscsi_initiator.enabled')
  if [ "$ISCSI_INITIATOR_ENABLED" = "true" ] ; then
    /etc/init.d/iscsid start
    /usr/local/bin/mos-iscsid_mount >/dev/null 2>&1 &
    sleep 2
  fi
}

# Inject IP into /etc/issue
modify_issue() {
  MOS_V=$(jq -r '"\(.mos.version)-\(.mos.channel)"' /etc/mos-release.json)
  echo -n '\n running MOS '"${MOS_V} - built on Devuan GNU/Linux" > /etc/issue
  echo "" >> /etc/issue
  for iface in eth0 br0; do
    ipv4=$(ip -4 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1)
    ipv6=$(ip -6 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet6\s)[0-9a-f:]+(?=/64)' | grep -v '^fe80' | head -1)
    if [ ! -z "$ipv4" ] || [ ! -z "$ipv6" ]; then
      echo "" >> /etc/issue
      [ ! -z "$ipv4" ] && echo "  IPv4: $ipv4" >> /etc/issue
      [ ! -z "$ipv6" ] && echo "  IPv6: $ipv6" >> /etc/issue
      break
    fi
  done
  echo "" >> /etc/issue
}

# Check if persist history is enabled and create symlink
persist_history() {
  PERSIST_HISTORY_ENABLED=$(echo $SYSTEM_JSON | jq -r '.persist_history')
  if [ "$PERSIST_HISTORY_ENABLED" = "true" ] ; then
    if [ ! -d "/boot/config/system" ] ; then
      mkdir -p /boot/config/system
    fi
    rm -f /root/.bash_history
    touch /boot/config/system/.bash_history
    ln -s /boot/config/system/.bash_history /root/.bash_history
  fi
}

# Update MOS Hub repositories on boot if configured
mos_hub_update() {
  HUB_ENALBED=$(echo $HUB_JSON | jq -r '.enabled')
  HUB_INITIAL_ENABLED=$(echo $HUB_JSON | jq -r '.initial_update')
  if [ "$HUB_ENALBED" = "true" ] && [ "$HUB_INITIAL_ENABLED" = "true" ] ; then
    node /usr/local/bin/mos-api_cli hub:update >/dev/null 2>&1 &
  fi
}

# Check if md5 boot check was successful
md5_check_result() {
  if [ -f /var/mos/badfiles ] ; then
    BAD_FILES=$(paste -sd',' /var/mos/badfiles | sed 's/,/, /g')
    notify -t "Boot MD5 Error" -m "Boot MD5 check finished with error(s) on file(s): $BAD_FILES! \nPlease check your installation!" -p alert
    rm -f /var/mos/badfiles
  fi
}

# SWAP
start_swap() {
  SWAP=$(echo $SYSTEM_JSON | jq -r '.swapfile.enabled')
  if [ "$SWAP" = "true" ] ; then
    SWAP_PATH=$(echo $SYSTEM_JSON | jq -r '.swapfile.path')
    SWAP_PRIORITY=$(echo $SYSTEM_JSON | jq -r '.swapfile.priority')
    ZSWAP=$(echo $SYSTEM_JSON | jq -r '.swapfile.config.zswap')
    if [ -f "$SWAP_PATH/.swapfile" ] ; then
      swapon --priority "$SWAP_PRIORITY" "$SWAP_PATH/.swapfile"
      if [ "$ZSWAP" = "true" ] ; then
        ZSWAP_SHRINKER=$(echo $SYSTEM_JSON | jq -r 'if .swapfile.config.shrinker then "Y" else "N" end')
        ZSWAP_MAX_POOL=$(echo $SYSTEM_JSON | jq -r '.swapfile.config.max_pool_percent')
        ZSWAP_COMPRESSOR=$(echo $SYSTEM_JSON | jq -r '.swapfile.config.compressor')
        ZSWAP_ACCEPT_THRESHOLD=$(echo $SYSTEM_JSON | jq -r '.swapfile.config.accept_threshold_percent')
        echo "$ZSWAP_SHRINKER" > /sys/module/zswap/parameters/shrinker_enabled
        echo "$ZSWAP_MAX_POOL" > /sys/module/zswap/parameters/max_pool_percent
        echo "$ZSWAP_COMPRESSOR" > /sys/module/zswap/parameters/compressor
        echo "$ZSWAP_SHRINKER" > /sys/module/zswap/parameters/shrinker_enabled
        echo "$ZSWAP_ACCEPT_THRESHOLD" > /sys/module/zswap/parameters/accept_threshold_percent
        echo "Y" > /sys/module/zswap/parameters/enabled
      fi
    else
      logger -t "MOS SWAP" "ERROR: Swapfile not found, not creating swap"
      return
    fi
  fi
}

# Format function for zram ramdisks
format_zram_ramdisk() {
  if [ "$1" = "ext4" ] ; then
    mkfs.ext4 -F -U $2 $3 >/dev/null 2>&1
  elif [ "$1" = "xfs" ] ; then
    mkfs.xfs -f -m uuid=$2 $3 >/dev/null 2>&1
  elif [ "$1" = "btrfs" ] ; then
    mkfs.btrfs -f -U $2 $3 >/dev/null 2>&1
  else
    return 1
  fi
}

# zram swap/ramdisk
start_zram() {
  ZRAM=$(echo $ZRAM_JSON | jq -r '.enabled')
  if [ "$ZRAM" = "true" ] ; then
    ZRAM_DEVICES=$(echo $ZRAM_JSON | jq -r '.zram_devices')
    if [ "$ZRAM_DEVICES" -gt "0" ] ; then
      modprobe zram num_devices=$ZRAM_DEVICES
      ZRAM_SWAP=$(echo "$ZRAM_JSON" | jq -r '.devices[] | select(.type == "swap") | .index // ""')
      ZRAM_RAMDISK=$(echo "$ZRAM_JSON" | jq -r '.devices[] | select(.type == "ramdisk") | .index // ""')
      for swap in $ZRAM_SWAP
      do
        ZRAM_SWAP_JSON=$(echo "$ZRAM_JSON" | jq -r --arg index "$swap" '.devices[] | select(.index == ($index | tonumber))')
        ZRAM_SWAP_ENABLED=$(echo "$ZRAM_SWAP_JSON" | jq -r '.enabled')
        [ "$ZRAM_SWAP_ENABLED" != "true" ] && \
          continue
        ZRAM_SWAP_INDEX=$(echo "$ZRAM_SWAP_JSON" | jq -r '.index')
        ZRAM_SWAP_ALGORITHM=$(echo "$ZRAM_SWAP_JSON" | jq -r '.algorithm')
        ZRAM_SWAP_SIZE=$(echo "$ZRAM_SWAP_JSON" | jq -r '.size')
        ZRAM_SWAP_PRIORITY=$(echo "$ZRAM_SWAP_JSON" | jq -r '.config.priority // "-2"')
        zramctl /dev/zram${ZRAM_SWAP_INDEX} --algorithm ${ZRAM_SWAP_ALGORITHM} --size ${ZRAM_SWAP_SIZE}
        mkswap "/dev/zram${ZRAM_SWAP_INDEX}" >/dev/null 2>&1
        swapon --priority "$ZRAM_SWAP_PRIORITY" "/dev/zram${ZRAM_SWAP_INDEX}" >/dev/null 2>&1
      done
      for ramdisk in $ZRAM_RAMDISK
      do
        ZRAM_RAMDISK_JSON=$(echo "$ZRAM_JSON" | jq -r --arg index "$ramdisk" '.devices[] | select(.index == ($index | tonumber))')
        ZRAM_RAMDISK_ENABLED=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.enabled')
        [ "$ZRAM_RAMDISK_ENABLED" != "true" ] && \
          continue
        ZRAM_RAMDISK_INDEX=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.index')
        ZRAM_RAMDISK_ALGORITHM=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.algorithm')
        ZRAM_RAMDISK_SIZE=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.size')
        ZRAM_RAMDISK_UUID=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.config.uuid')
        ZRAM_RAMDISK_FILESYSTEM=$(echo "$ZRAM_RAMDISK_JSON" | jq -r '.config.filesystem')
        zramctl /dev/zram${ZRAM_RAMDISK_INDEX} --algorithm ${ZRAM_RAMDISK_ALGORITHM} --size ${ZRAM_RAMDISK_SIZE}
        format_zram_ramdisk "$ZRAM_RAMDISK_FILESYSTEM" "$ZRAM_RAMDISK_UUID" "/dev/zram${ZRAM_RAMDISK_INDEX}"
        EXIT_STATUS=$?
        if [ "$EXIT_STATUS" != "0" ] ; then
          echo "ERROR: Format failed for zram ramdisk /dev/zram${$ZRAM_RAMDISK_INDEX}"
          continue
        fi
      done
    fi
  fi
}

# Define argument conditions
if [ "$1" = "os" ] ; then
  STARTUP_SOUND=$(echo $SYSTEM_JSON | jq -r '.notification_sound.startup')
  if [ "$STARTUP_SOUND" != "null" ] && [ "$STARTUP_SOUND" != "false" ] ; then
    beep -f 500 -l 150 -n -f 580 -l 150
  fi
  start_notify
  start_smart
  start_sensors_detect
  start_script
  modify_issue
  start_ntp
  persist_history
  start_ssh
  start_tailscale
  start_netbird
  start_iscsi_initiator
  start_zram
  mount_disks
  start_iscsi_target
  mount_remotes
  start_swap
  optional_packages
  start_nut
  start_nmbd
  start_samba
  start_nfs
  start_docker
  docker_network_check
  docker_autostart
  start_lxc
  start_vm
  start_nginx
  start_api
  mos_hub_update
  mos_spindown
  start_cron
  md5_check_result
  end_script
  STARTUP_SOUND=$(echo $SYSTEM_JSON | jq -r '.notification_sound.startup')
  if [ "$STARTUP_SOUND" != "null" ] && [ "$STARTUP_SOUND" != "false" ] ; then
    beep -f 523 -l 100 -n -f 587 -l 100 -n -f 659 -l 200
  fi
  write_run
elif [ "$1" = "docker" ] ; then
  start_docker
  docker_network_check
  docker_autostart
elif [ "$1" = "lxc" ] ; then
  start_lxc
elif [ "$1" = "vm" ] ; then
  start_vm
elif [ "$1" = "nmbd" ] ; then
  start_nmbd
elif [ "$1" = "samba" ] ; then
  start_samba
elif [ "$1" = "tailscale" ] ; then
  start_tailscale
elif [ "$1" = "netbird" ] ; then
  start_netbird
elif [ "$1" = "nut" ] ; then
  start_nut
elif [ "$1" = "iscsi-initiator" ] ; then
  start_iscsi_initiator
elif [ "$1" = "iscsi-target" ] ; then
  start_iscsi_target
fi
