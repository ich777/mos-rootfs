#!/bin/sh
# Put all JSONs into Variables
SYSTEM_JSON=$(jq '.' /boot/config/system.json)
DOCKER_JSON=$(jq '.' /boot/config/docker.json)
LXC_JSON=$(jq '.' /boot/config/lxc.json)
VM_JSON=$(jq '.' /boot/config/vm.json)
NETWORK_JSON=$(jq '.' /boot/config/network.json)

# Execute echo to get one emty line
echo

# Execute start script if found
start_script() {
  if [ -f /boot/optional/scripts/pre-start.sh ] ; then
    cp /boot/optional/scripts/pre-start.sh /tmp/pre-start.sh
    chmod +x /tmp/pre-start.sh
    ( /tmp/pre-start.sh )
    rm -f /tmp/pre-start.sh
  fi
}

# Execute end script if found
end_script() {
  if [ -f /boot/optional/scripts/post-start.sh ] ; then
    cp /boot/optional/scripts/post-start.sh /tmp/post-start.sh
    chmod +x /tmp/post-start.sh
    ( /tmp/post-start.sh )
    rm -f /tmp/post-start.sh
  fi
}

# Write file to /run that MOS bootscript is done
write_run() {
  echo "Don't remove this file" > /run/mos-booted
}

# Start notify service
start_notify() {
  /etc/init.d/notify start
}

# Start smartmontools
start_smart() {
  /etc/init.d/smartmontools start
}

# Start cron service
start_cron() {
  /etc/init.d/cron start
}

# Start ssh service if enabled
start_ssh() {
  SSH_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.ssh.enabled')
  if [ "$SSH_ENABLED" = "true" ] ; then
    /etc/init.d/ssh start
  fi
}

# Start ntpd service if enabled
start_ntp() {
  NTP_ENABLED=$(echo $SYSTEM_JSON | jq -r '.ntp.enabled')
  if [ "$NTP_ENABLED" = "true" ] ; then
    /etc/init.d/ntpsec start
  fi
}

# Start nginx service for the WebUI
start_nginx() {
  /etc/init.d/nginx start
}

# Start MOS API service
start_api() {
  /etc/init.d/api start
}

# Mount disks
mount_disks() {
  /usr/local/bin/mos-mount_disks
}

# Start NUT UPS service if enabled
start_nut() {
  NUT_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.nut.enabled')
  if [ "$NUT_ENABLED" = "true" ] ; then
    /etc/init.d/nut-server start
    /etc/init.d/nut-client start
  fi
}

# Install optional .deb packages
optional_packages() {
  OPTIONAL_PACKAGES=$(ls -1 /boot/optional/packages/)
  if [ ! -z "$OPTIONAL_PACKAGES" ] ; then
    logger "Installing additional packages"
    for package in $OPTIONAL_PACKAGES
    do
      logger "Installing: $package"
      DEBIAN_FRONTEND=noninteractive dpkg -i /boot/optional/packages/$package >/dev/null 2>&1
    done
  fi
}

# Create Docker network interface for ipvlan/macvlan
docker_network_create() {
  DOCKER_NET_CONFIG=$(echo $DOCKER_JSON | jq -r '.docker_net.config')

  if [ "$(echo $DOCKER_NET_CONFIG | jq '. | length')" = "0" ] ; then
    DOCKER_SUBNET="$(ip route show dev $1 | awk '/src/ {print $1}')"
    DOCKER_GATEWAY="$(ip route show default 0.0.0.0/0 dev $1 | awk '{print $3}')"
  else
    DOCKER_SUBNET="$(echo $DOCKER_NET_CONFIG | jq -r '.[].subnet')"
    DOCKER_GATEWAY="$(echo $DOCKER_NET_CONFIG | jq -r '.[].gateway')"
  fi

  docker network create -d $2 \
  --subnet=$DOCKER_SUBNET \
  --gateway=$DOCKER_GATEWAY \
  -o parent=$1 \
  $1 >/dev/null 2>&1
}

# Check if Docker interface for ipvlan/macvlan is already in place
docker_network_check() {
  DOCKER_NET_MODE=$(echo $DOCKER_JSON | jq -r '.docker_net.mode')
  INTERFACE_MODE=$(echo $NETWORK_JSON | jq -r '.interfaces[] | select(.name == "eth0") | .type')
  if [ "$INTERFACE_MODE" = "bridged" ] ; then
    INTERFACE=br0
  else
    INTERFACE=eth0
  fi
  # Check for Docker networks where the parent is non existent
  if [ "$INTERFACE" = "br0" ] ; then
    if docker network inspect eth0 >/dev/null 2>&1; then
      docker network rm --force eth0 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  else
    if docker network inspect br0 >/dev/null 2>&1; then
      docker network rm --force br0 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  fi
  # Check for Docker networks with wrong net_mode
  if [ "$DOCKER_NET_MODE" = "ipvlan" ] ; then
    if [ "$(docker network inspect $1 >/dev/null 2>&1 | jq -r '.[].Driver')" = "macvlan" ] ; then
      docker network rm --force $1 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  elif [ "$DOCKER_NET_MODE" = "macvlan" ] ; then
    if [ "$(docker network inspect $1 >/dev/null 2>&1 | jq -r '.[].Driver')" = "ipvlan" ] ; then
      docker network rm --force $1 >/dev/null 2>&1
      docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
    fi
  fi
  # Create Docker network if it not exists
  if ! docker network inspect $1 >/dev/null 2>&1; then
    docker_network_create "$INTERFACE" "$DOCKER_NET_MODE"
  fi
}

# Execute Docker autostart
docker_autostart() {
  /usr/local/bin/mos-docker_autostart >/dev/null 2>&1 &
}

# Start Docker service if enabled
start_docker() {
  DOCKER_ENABLED=$(echo $DOCKER_JSON | jq -r '.enabled')
  if [ "$DOCKER_ENABLED" = "true" ] ; then
    DOCKER_APPDATA=$(echo $DOCKER_JSON | jq -r '.appdata')
    DOCKER_OPTIONS=$(echo $DOCKER_JSON | jq -r '.docker_options // ""')
    if [ ! -d $DOCKER_APPDATA ] ; then
      mkdir -p $DOCKER_APPDATA
    fi
    DOCKER_OPTS="$DOCKER_OPTIONS" /etc/init.d/docker start
  fi
}


# Start LXC service if enabled (and lxc-net if enabled)
start_lxc() {
  LXC_ENABLED=$(echo $LXC_JSON | jq -r '.enabled')
  if [ "$LXC_ENABLED" = "true" ] ; then
    LXC_DIRECTORY=$(echo $LXC_JSON | jq -r '.directory')
    LXC_BRIDGE=$(echo $LXC_JSON | jq -r '.bridge')
    /etc/init.d/lxc "start" "$LXC_DIRECTORY"
    /usr/local/bin/mos-lxc_autostart >/dev/null 2>&1 &
    if [ "$LXC_BRIDGE" = "true" ]; then
      /etc/init.d/lxc-net start
    fi
  fi
}

# Start VM services if enabled
start_vm() {
  VM_ENABLED=$(echo $VM_JSON | jq -r '.enabled')
  if [ "$VM_ENABLED" = "true" ] ; then
    /etc/init.d/libvirtd start
    /etc/init.d/virtlogd start
  fi
}

# Start nmbd service if enabled (SAMBA Discovery)
start_nmbd() {
  NMBD_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.nmbd.enabled')
  if [ "$NMBD_ENABLED" = "true" ] ; then
    /etc/init.d/nmbd start
  fi
}

# Start SAMBA service if enabled
start_samba() {
  SAMBA_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.samba.enabled')
  if [ "$SAMBA_ENABLED" = "true" ] ; then
    /etc/init.d/smbd start
  fi
}

# Start Tailscale service if enabled
start_tailscale() {
  TAILSCALE_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.tailscale.enabled')
  if [ "$TAILSCALE_ENABLED" = "true" ] ; then
    /etc/init.d/tailscaled start
  fi
}

# Start Netbird service if enabled
start_netbird() {
  NETBIRD_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.netbird.enabled')
  if [ "$NETBIRD_ENABLED" = "true" ] ; then
    /etc/init.d/netbird start
  fi
}

# Execute scripts to set disk standby timeouts and start spindown watchdog for disks
mos_spindown() {
  DISKS=$(find /dev/ -name sd?)
  for disk in $DISKS
  do
    nohup /usr/local/bin/mos-set_spindown $disk >/dev/null 2>&1 &
    setsid /usr/local/bin/mos-spindown_watchdog $disk &>/dev/null < /dev/null &
  done
}

# Start iSCSI Target service if enabled
start_iscsi_target() {
  ISCSI_TARGET_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.iscsi_target.enabled')
  if [ "$ISCSI_TARGET_ENABLED" = "true" ] ; then
    /etc/init.d/tgt start
  fi
}


# Mount Remotes if remote_mounting is enabled
mount_remotes() {
  REMOTE_MOUNTS_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.remote_mounting.enabled')
  if [ "$REMOTE_MOUNTS_ENABLED" = "true" ] ; then
    /usr/local/bin/mos-mount_remotes &
  fi
}

# Start iSCSI Initiator service if enabled and mount Targets
start_iscsi_initiator() {
  ISCSI_INITIATOR_ENABLED=$(echo $NETWORK_JSON | jq -r '.services.iscsi_initiator.enabled')
  if [ "$ISCSI_INITIATOR_ENABLED" = "true" ] ; then
    /etc/init.d/iscsid start
    /usr/local/bin/mos-iscsid_mount >/dev/null 2>&1 &
    sleep 2
  fi
}

# Inject IP into /etc/issue
modify_issue() {
  MOS_V=$(jq -r '"\(.mos.version)-\(.mos.channel)"' /etc/mos-release.json)
  echo -n '\n running MOS '"${MOS_V} - built on Devuan GNU/Linux" > /etc/issue
  echo "" >> /etc/issue
  for iface in eth0 br0; do
    ipv4=$(ip -4 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1)
    ipv6=$(ip -6 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet6\s)[0-9a-f:]+(?=/64)' | grep -v '^fe80' | head -1)
    if [ ! -z "$ipv4" ] || [ ! -z "$ipv6" ]; then
      echo "" >> /etc/issue  # Eine Leerzeile
      [ ! -z "$ipv4" ] && echo "  IPv4: $ipv4" >> /etc/issue
      [ ! -z "$ipv6" ] && echo "  IPv6: $ipv6" >> /etc/issue
      break
    fi
  done
  echo "" >> /etc/issue
}

# Check if persist history is enabled and create symlink
persist_history() {
  PERSIST_HISTORY_ENABLED=$(echo $SYSTEM_JSON | jq -r '.persist_history')
  if [ "$PERSIST_HISTORY_ENABLED" = "true" ] ; then
    if [ ! -d "/boot/config/system" ] ; then
      mkdir -p /boot/config/system
    fi
    rm -f /root/.bash_history
    touch /boot/config/system/.bash_history
    ln -s /boot/config/system/.bash_history /root/.bash_history
  fi
}

# Define argument conditions
if [ "$1" = "os" ] ; then
  STARTUP_SOUND=$(echo $SYSTEM_JSON | jq -r '.notification_sound.startup')
  if [ "$STARTUP_SOUND" != "null" ] && [ "$STARTUP_SOUND" != "false" ] ; then
    beep -f 500 -l 150 -n -f 580 -l 150
  fi
  start_notify
  start_smart
  start_script
  modify_issue
  start_ntp
  persist_history
  start_ssh
  start_tailscale
  start_netbird
  start_iscsi_initiator
  mount_disks
  start_iscsi_target
  mount_remotes
  optional_packages
  start_nut
  start_nmbd
  start_samba
  start_docker
  docker_network_check
  docker_autostart
  start_lxc
  start_vm
  start_nginx
  start_api
  mos_spindown
  start_cron
  end_script
  STARTUP_SOUND=$(echo $SYSTEM_JSON | jq -r '.notification_sound.startup')
  if [ "$STARTUP_SOUND" != "null" ] && [ "$STARTUP_SOUND" != "false" ] ; then
    beep -f 523 -l 100 -n -f 587 -l 100 -n -f 659 -l 200
  fi
  write_run
elif [ "$1" = "docker" ] ; then
  start_docker
  docker_network_check
  docker_autostart
elif [ "$1" = "lxc" ] ; then
  start_lxc
elif [ "$1" = "vm" ] ; then
  start_vm
elif [ "$1" = "nmbd" ] ; then
  start_nmbd
elif [ "$1" = "samba" ] ; then
  start_samba
elif [ "$1" = "tailscale" ] ; then
  start_tailscale
elif [ "$1" = "netbird" ] ; then
  start_netbird
elif [ "$1" = "nut" ] ; then
  start_nut
elif [ "$1" = "iscsi-initiator" ] ; then
  start_iscsi_initiator
elif [ "$1" = "iscsi-target" ] ; then
  start_iscsi_target
fi
