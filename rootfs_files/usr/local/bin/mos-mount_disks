#!/bin/sh
PATH=$PATH:/usr/local/bin

# Get json and write it into variable
POOLS_JSON=$(jq '.[]' /boot/config/pools.json)
if [ -z "$1" ]; then
  POOLS=$(echo "$POOLS_JSON" | jq '.name')
  # Check for unclean shutdown
  if [ -f /boot/config/system/mos.chk ] ; then
    UNCLEAN_SHUTDOWN=true
  else
    UNCLEAN_SHUTDOWN=false
    echo "Please don't remove this files" > /boot/config/system/mos.chk
  fi
else
  POOLS="$1"
fi

# Create pool directory and mergerfs mount when pool is mergerfs
create_pool_directory() {
  if [ "$(mount | grep "/mnt/$1")" ] ; then
    return 1
  elif [ ! -d /mnt/$1 ] ; then
    mkdir -p /mnt/$1
  fi
  if [ "$2" == "mergerfs" ] ; then
    logger "Mounting mergerfs pool: $1"
    if [ ! -d /var/mergerfs/$1 ] ; then
      mkdir -p /var/mergerfs/$1
    fi
  fi
}

# Create mergerfs disk directory
mergerfs_create_disk_directory() {
  if [ ! -d /var/mergerfs/$1/disk$2 ] ; then
    mkdir -p /var/mergerfs/$1/disk$2
  fi
}

# Mount individual mergerfs disk and check for keys if it's a LUKS pool
mergerfs_mount_disk() {
  if [ ! "$(findmnt /var/mergerfs/$3/disk$4)" ]; then
    if [ "$7" == "nonraid" ] ; then
      DEVICE_PATH="/dev/nmd${4}p1"
    else
      DEVICE_PATH="/dev/disk/by-uuid/$2"
    fi
    if [ "$5" == "true" ] ; then
      if [ ! -z "$6" ] ; then
        echo "${6//\"/\\\"}" | cryptsetup open /dev/disk/by-uuid/$2 ${3}_${4}
      elif [ -f /tmp/luks/$3.key ] ; then
        cryptsetup open $DEVICE_PATH ${3}_${4} --key-file /tmp/luks/$3.key
      elif [ -f /boot/config/system/luks/$3.key ] ; then
        cryptsetup open $DEVICE_PATH ${3}_${4} --key-file /boot/config/system/luks/$3.key
      else
        logger "Can't mount encrypted disk$4 from pool: $3 without passphrase or keyfile"
        return 1
      fi
      mount -t $1 /dev/mapper/${3}_${4} /var/mergerfs/$3/disk$4
    else
      mount -t $1 $DEVICE_PATH /var/mergerfs/$3/disk$4
    fi
  fi
}

# Mount mergerfs pool to /mnt
mergerfs_mount_pool() {
  mergerfs -o defaults,allow_other,use_ino,category.create=$3 $1 /mnt/$2
}

# Create mergerfs pools for ep* policies
mergerfs_create_paths() {
  if [ ! -d /var/mergerfs/$1/disk$3/$2 ] ; then
    mkdir -p /var/mergerfs/$1/disk$3/$2
  fi
}

# Create SnapRAID disk directory
snapraid_create_parity_directory() {
  if [ ! -d /var/snapraid/$1/parity$2 ] ; then
    mkdir -p /var/snapraid/$1/parity$2
  fi
}

# Mount individual SnapRAID disk and check for keys if it's a LUKS pool
snapraid_mount_disk() {
  if [ ! "$(findmnt /var/snapraid/$3/parity$4)" ]; then
    if [ "$5" == "true" ] ; then
      if [ ! -z "$6" ] ; then
        echo "${6//\"/\\\"}" | cryptsetup open /dev/disk/by-uuid/$2 parity_${3}_${4}
      elif [ -f /tmp/luks/$3.key ] ; then
        cryptsetup open /dev/disk/by-uuid/$2 parity_${3}_${4} --key-file /tmp/luks/$3.key
      elif [ -f /boot/config/system/luks/$3.key ] ; then
        cryptsetup open /dev/disk/by-uuid/$2 parity_${3}_${4} --key-file /boot/config/system/luks/$3.key
      else
        logger "Can't mount encrypted parity$4 from pool: $3 without passphrase or keyfile"
        return 1
      fi
      mount -t $1 /dev/mapper/parity_${3}_${4} /var/snapraid/$3/parity$4
    else
      mount -t $1 /dev/disk/by-uuid/$2 /var/snapraid/$3/parity$4
    fi
  fi
}

# Decrypt BTRFS LUKS pool
btrfs_luks_open() {
  if [ ! -z "$4" ] ; then
    echo "${4//\"/\\\"}" | cryptsetup open /dev/disk/by-uuid/$1 ${2}_${3}
  elif [ -f /tmp/luks/$2.key ] ; then
    cryptsetup open /dev/disk/by-uuid/$1 ${2}_${3} --key-file /tmp/luks/$2.key
  elif [ -f /boot/config/system/luks/$2.key ] ; then
    cryptsetup open /dev/disk/by-uuid/$1 ${2}_${3} --key-file /boot/config/system/luks/$2.key
  else
    logger "Can't mount encrypted pool $2 without passphrase or keyfile"
    return 1
  fi
}

# Mount BTRFS Pool
btrfs_mount_pool() {
  if [ "$3" == "true" ] ; then
    mount ${1}/${2}_1 /mnt/$2
  else
    mount /dev/disk/by-uuid/$1 /mnt/$2
  fi
}

# Mount ext4 disk and check if it's a LUKS encrypted
ext4_mount_disk() {
  if [ "$3" == "true" ] ; then
    if [ ! -z "$4" ] ; then
      echo "${4//\"/\\\"}" | cryptsetup open /dev/disk/by-uuid/$1 ${2}_1
    elif [ -f /tmp/luks/$2.key ] ; then
      cryptsetup open /dev/disk/by-uuid/$1 ${2}_1 --key-file /tmp/luks/$2.key
    elif [ -f /boot/config/system/luks/$2.key ] ; then
      cryptsetup open /dev/disk/by-uuid/$1 ${2}_1 --key-file /boot/config/system/luks/$2.key
    else
      logger "Can't mount encrypted pool $2 without passphrase or keyfile"
      return 1
    fi
    mount -t ext4 /dev/mapper/${2}_1 /mnt/$2
  else
    mount -t ext4 /dev/disk/by-uuid/$1 /mnt/$2
  fi
}

# Mount xfs disk and check if it's a LUKS encrypted
xfs_mount_disk() {
  if [ "$3" == "true" ] ; then
    if [ ! -z "$4" ] ; then
      echo "${4//\"/\\\"}" | cryptsetup open /dev/disk/by-uuid/$1 ${2}_1
    elif [ -f /tmp/luks/$2.key ] ; then
      cryptsetup open /dev/disk/by-uuid/$1 ${2}_1 --key-file /tmp/luks/$2.key
    elif [ -f /boot/config/system/luks/$2.key ] ; then
      cryptsetup open /dev/disk/by-uuid/$1 ${2}_1 --key-file /boot/config/system/luks/$2.key
    else
      logger "Can't mount encrypted pool $2 without passphrase or keyfile"
      return 1
    fi
    mount -t xfs /dev/mapper/${2}_1 /mnt/$2
  else
    mount -t xfs /dev/disk/by-uuid/$1 /mnt/$2
  fi
}

# Execute script if one is found after pool is mounted
mount_script() {
  if [ -f "/boot/optional/scripts/pools/mounted/$1.sh" ] ; then
    bash /boot/optional/scripts/pools/mounted/$1.sh >/dev/null 2>&1 &
  fi
}

# Loop through pools and try to mount them if automount is enabled
for POOL in $POOLS
do
  POOL=$(echo "$POOL" | xargs)
  POOL_JSON=$(echo "$POOLS_JSON" | jq --arg pool_name "$POOL" '. | select(.name == $pool_name)')
  if [ -z "$1" ] && [ "$(echo $POOL_JSON | jq -r '.automount')" != "true" ] ; then
    continue
  fi
  POOL_TYPE=$(echo $POOL_JSON | jq -r '.type')
  POOL_ENCRYPTED=$(echo $POOL_JSON | jq '.config.encrypted')
  if [ "$POOL_ENCRYPTED" == "true" ] ; then
    ENCRYPTED_TEXT=" encrypted"
    if [ ! -z "$2" ] ; then 
      DECRYPTION_KEY=$(echo "$2" | xargs)
    fi
  fi
  if [ "$POOL_TYPE" == "mergerfs" ] ; then
    create_pool_directory "$POOL" "$POOL_TYPE" || { echo "Pool $POOL already mounted" ; continue ; }
    CREATE_POLICY=$(echo $POOL_JSON | jq -r '.config.policies.create')
    for data_slot in $(echo $POOL_JSON | jq -r '.data_devices[].slot')
    do
      mergerfs_create_disk_directory "$POOL" "$data_slot"
      DISK_DETAILS=$(echo "$POOL_JSON" | jq -r --arg data_slot "$data_slot" '.data_devices[] | select(.slot == $data_slot)')
      DISK_ID=$(echo "$DISK_DETAILS" | jq -r '.id')
      DISK_FS=$(echo "$DISK_DETAILS" | jq -r '.filesystem')
      logger "Mounting$ENCRYPTED_TEXT mergerfs disk${DISK_ID} from: $POOL"
      mergerfs_mount_disk "$DISK_FS" "$DISK_ID" "$POOL" "$data_slot" "$POOL_ENCRYPTED" "$DECRYPTION_KEY"
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" != "0" ] ; then
        umount /mnt/$POOL >/dev/null 2>&1
        rmdir /mnt/$POOL >/dev/null 2>&1
        continue 2
      fi
      if [ -z "$MOUNTS" ] ; then
        MOUNTS="/var/mergerfs/$POOL/disk$data_slot"
      else
        MOUNTS="$MOUNTS:/var/mergerfs/$POOL/disk$data_slot"
      fi
    done
    mergerfs_mount_pool "$MOUNTS" "$POOL" "$CREATE_POLICY"
    PARITY_COUNT=$(echo $POOL_JSON | jq -r '.parity_devices | length')
    if [ "$PARITY_COUNT" != "0" ] ; then
      for parity_slot in $(echo $POOL_JSON | jq -r '.parity_devices[].slot')
      do
        PARITY_DETAILS=$(echo "$POOL_JSON" | jq -r --arg parity_slot "$parity_slot" '.parity_devices[] | select(.slot == $parity_slot)')
        PARITY_ID=$(echo "$PARITY_DETAILS" | jq -r '.id')
        PARITY_FS=$(echo "$PARITY_DETAILS" | jq -r '.filesystem')
        snapraid_create_parity_directory "$POOL" "$parity_slot"
        logger "Mounting$ENCRYPTED_TEXT snapraid parity${PARITY_ID} from: $POOL"
        snapraid_mount_disk "$PARITY_FS" "$PARITY_ID" "$POOL" "$parity_slot" "$POOL_ENCRYPTED" "$DECRYPTION_KEY"
      done
    fi
    PATH_RULE_COUNT=$(echo $POOL_JSON | jq -r '.config.path_rules | length')
    if [ "$PATH_RULE_COUNT" != "0" ] ; then
      for path in $(echo $POOL_JSON | jq -r '.config.path_rules[].path')
      do
        RULE_TARGETS=$(echo "$POOL_JSON" | jq -r --arg path "$path" '.config.path_rules[] | select(.path == $path) | .target_devices[]')
        if [ "$RULE_TARGETS" != "0" ] ; then
          for target_device in $RULE_TARGETS
          do
            mergerfs_create_paths "$POOL" "${path#/}" "$target_device"
          done
        fi
      done
    fi
  elif [ "$POOL_TYPE" == "nonraid" ] ; then
    # Make sure module is available and activated
    ! modinfo md-nonraid >/dev/null 2>&1 && \
      continue
    lsmod | grep -qE "md.nonraid" && \
      continue

    # Create pool directory and exit early if directory is already found
    create_pool_directory "$POOL" "mergerfs" || { echo "Pool $POOL already mounted" ; continue ; }

    # Load nonraid module with nonraid.dat path
    modprobe md-nonraid super=/boot/config/system/nonraid.dat

    # Wait to make sure everything is loaded correctly
    sleep 1

    # Get stats
    NONRAID_STAT=$(cat /proc/nmdstat)

    # Loop through parity disks
    for parity in 0 29
    do
      # Skip unassigned disks
      ID=$(grep "diskId\.$parity=" <<< "$NONRAID_STAT" | cut -d '=' -f2)
      [ -z "$ID" ] && \
        continue
      DEV_PATH=$(readlink -f /dev/disk/by-id/$ID | sed 's|^/dev/||')
      SIZE=$(( $(blockdev --getsz /dev/disk/by-id/$ID) / 2 ))
      # MOS Missing: Check against pools.json if disk is actually present
      echo "import $parity $DEV_PATH 0 $SIZE 0 $ID" > /proc/nmdcmd
    done

    # Loop through data disks
    for disk in {1..28}
    do
      # Skip unassigned disks
      UUID=$(grep "diskId\.$disk=" <<< "$NONRAID_STAT" | cut -d '=' -f2)
      [ -z "$UUID" ] && \
        continue
      DEV_PATH=$(readlink -f /dev/disk/by-uuid/$UUID | sed 's|^/dev/||')
      SIZE=$(( $(blockdev --getsz /dev/disk/by-uuid/$UUID) / 2 ))
      # MOS Missing: Check against pools.json if disk is actually present
      echo "import $disk $DEV_PATH 0 $SIZE 0 $UUID" > /proc/nmdcmd
    done

    # Try to start nonraid
    NONRAID_STATUS=$(cat /proc/nmdstat | grep "mdState=" | cut -d '=' -f2)
    if [ "$NONRAID_STATUS" = "STOPPED" ] ; then
      echo "start" > /proc/nmdcmd
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" != "0" ] ; then
        continue
      fi
    else
      logger "Can't mount nonraid disks, nonraid status: $NONRAID_STATUS"
      continue
    fi

    CREATE_POLICY=$(echo $POOL_JSON | jq -r '.config.policies.create')
    for data_slot in $(echo $POOL_JSON | jq -r '.data_devices[].slot')
    do
      mergerfs_create_disk_directory "$POOL" "$data_slot"
      DISK_DETAILS=$(echo "$POOL_JSON" | jq -r --arg data_slot "$data_slot" '.data_devices[] | select(.slot == $data_slot)')
      DISK_ID=$(echo "$DISK_DETAILS" | jq -r '.id')
      DISK_FS=$(echo "$DISK_DETAILS" | jq -r '.filesystem')
      logger "Mounting$ENCRYPTED_TEXT mergerfs disk${DISK_ID} from: $POOL"
      mergerfs_mount_disk "$DISK_FS" "$DISK_ID" "$POOL" "$data_slot" "$POOL_ENCRYPTED" "$DECRYPTION_KEY" "nonraid"
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" != "0" ] ; then
        umount /mnt/$POOL >/dev/null 2>&1
        rmdir /mnt/$POOL >/dev/null 2>&1
        for disk in /var/mergerfs/$POOL/*
        do
          umount "$disk" >/dev/null 2>&1
          rmdir "$disk" >/dev/null 2>&1
        done
        rmdir /var/mergerfs/$POOL
        { echo "nocheck CANCEL" > /proc/nmdcmd; } 2>/dev/null
        { echo "stop" > /proc/nmdcmd; } 2>/dev/null
        continue 2
      fi
      if [ -z "$MOUNTS" ] ; then
        MOUNTS="/var/mergerfs/$POOL/disk$data_slot"
      else
        MOUNTS="$MOUNTS:/var/mergerfs/$POOL/disk$data_slot"
      fi
    done
    mergerfs_mount_pool "$MOUNTS" "$POOL" "$CREATE_POLICY"
    # Add control file if not exists or start parity check
    if [ "$UNCLEAN_SHUTDOWN" == "true" ] ; then
      { echo "check" > /proc/nmdcmd; } 2>/dev/null
      notify -t "MOS System" -m "Unclean shutdown detected! Parity check for $POOL started" -p "alert"
    fi
    PATH_RULE_COUNT=$(echo $POOL_JSON | jq -r '.config.path_rules | length')
    if [ "$PATH_RULE_COUNT" != "0" ] ; then
      for path in $(echo $POOL_JSON | jq -r '.config.path_rules[].path')
      do
        RULE_TARGETS=$(echo "$POOL_JSON" | jq -r --arg path "$path" '.config.path_rules[] | select(.path == $path) | .target_devices[]')
        if [ "$RULE_TARGETS" != "0" ] ; then
          for target_device in $RULE_TARGETS
          do
            mergerfs_create_paths "$POOL" "${path#/}" "$target_device"
          done
        fi
      done
    fi
  elif [ "$POOL_TYPE" == "btrfs" ] ; then
    create_pool_directory "$POOL" "$POOL_TYPE" || { echo "Pool $POOL already mounted" ; continue ; }
    logger "Mounting$ENCRYPTED_TEXT btrfs pool: $POOL"
    DISK_ID=$(echo "$POOL_JSON" | jq -r --arg disk_no "$DISK_NO" '.data_devices[0].id')
    if [ "$POOL_ENCRYPTED" == "true" ] ; then
      for data_slot in $(echo $POOL_JSON | jq -r '.data_devices[].slot')
      do
        DISK_DETAILS=$(echo "$POOL_JSON" | jq -r --arg data_slot "$data_slot" '.data_devices[] | select(.slot == $data_slot)')
        DISK_ID_BTRFS=$(echo "$DISK_DETAILS" | jq -r '.id')
        btrfs_luks_open "$DISK_ID_BTRFS" "$POOL" "$data_slot" "$DECRYPTION_KEY"
      done
      btrfs_mount_pool "/dev/mapper/" "$POOL" "true"
      EXIT_STATUS=$?
      if [ "$EXIT_STATUS" == "1" ] ; then
        umount /mnt/$POOL >/dev/null 2>&1
        rmdir /mnt/$POOL
        continue 2
      fi
    else
      btrfs_mount_pool "$DISK_ID" "$POOL" "false"
    fi
  elif [ "$POOL_TYPE" == "ext4" ] ; then
    create_pool_directory "$POOL" "$POOL_TYPE" || { echo "Pool $POOL already mounted" ; continue ; }
    logger "Mounting$ENCRYPTED_TEXT ext4 disk: $POOL"
    DISK_ID=$(echo "$POOL_JSON" | jq -r --arg disk_no "$DISK_NO" '.data_devices[0].id')
    ext4_mount_disk "$DISK_ID" "$POOL" "$POOL_ENCRYPTED" "$DECRYPTION_KEY"
    EXIT_STATUS=$?
    if [ "$EXIT_STATUS" != "0" ] ; then
      umount /mnt/$POOL >/dev/null 2>&1
      rmdir /mnt/$POOL
      continue 2
    fi
  elif [ "$POOL_TYPE" == "xfs" ] ; then
    create_pool_directory "$POOL" "$POOL_TYPE" || { echo "Pool $POOL already mounted" ; continue ; }
    logger "Mounting$ENCRYPTED_TEXT xfs disk: $POOL"
    DISK_ID=$(echo "$POOL_JSON" | jq -r --arg disk_no "$DISK_NO" '.data_devices[0].id')
    xfs_mount_disk "$DISK_ID" "$POOL" "$POOL_ENCRYPTED" "$DECRYPTION_KEY"
    EXIT_STATUS=$?
    if [ "$EXIT_STATUS" != "0" ] ; then
      umount /mnt/$POOL >/dev/null 2>&1
      rmdir /mnt/$POOL
      continue 2
    fi
  fi
  mount_script "$POOL"
  unset POOL_JSON DISK_COUNT DISK_NO MOUNTS PARITY_COUNT POOL_ENCRYPTED ENCRYPTED_TEXT KEY EXIT_STATUS
done

# Make sure to remove temporary LUKS files
if [ -d /tmp/luks ] ; then
  rm -rf /tmp/luks
fi
