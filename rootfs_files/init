#!/bin/bash
# Mount necessary system directories
/bin/mount -t proc none /proc
/bin/mount -t sysfs none /sys
/bin/mount -t devtmpfs none /dev

# Make Kernel less noisy in terminal
/bin/echo 4 > /proc/sys/kernel/printk

# Remove microcode update directories
/bin/rm -rf /kernel

# Display MOS Banner and MOS version
/bin/echo "░  ░░░░  ░░░      ░░░░      ░░"
/bin/echo "▒   ▒▒   ▒▒  ▒▒▒▒  ▒▒  ▒▒▒▒▒▒▒"
/bin/echo "▓        ▓▓  ▓▓▓▓  ▓▓▓      ▓▓"
/bin/echo "█  █  █  ██  ████  ████████  █"
/bin/echo "█  ████  ███      ████      ██"
/bin/echo "Version: $(/usr/bin/jq -r '"\(.mos.version)-\(.mos.channel)"' /etc/mos-release.json)"
/bin/echo

# Get boot label if set or set to default
BOOT_LABEL="$(/bin/cat /proc/cmdline | /bin/grep "BOOT_LABEL" | /bin/grep -o 'BOOT_LABEL=[^"]*' | /usr/bin/cut -d '=' -f2)"
if [ -z "$BOOT_LABEL" ] ; then
  BOOT_LABEL="MOS"
fi
/bin/echo "Setting boot label to: $BOOT_LABEL"

# Get device to boot from
for i in $(/usr/bin/seq 1 15); do
  BOOT_DEVICE="$(/sbin/blkid -L "$BOOT_LABEL")"
  [ ! -z "$BOOT_DEVICE" ] && break
  /bin/sleep 1
done

if [ -z "$BOOT_DEVICE" ] ; then
  /bin/echo "ERROR: MOS boot device with label: $BOOT_LABEL not found"
  /bin/sleep infinity
else 
  /bin/echo "Setting boot device to: $BOOT_DEVICE"
fi

# Get filesystem type
BOOT_FS_TYPE=$(/sbin/blkid -s TYPE "$BOOT_DEVICE" | /bin/grep -oP 'TYPE="\K[^"]*')

# Fix permissions if necessary
fix_boot_permissions() {
  /bin/chown -R root:root /boot 2>/dev/null
  /bin/chmod -R 600 /boot 2>/dev/null
}

# Mount boot device
/bin/mkdir -p /boot 2>/dev/null
/bin/echo "Trying to mount $BOOT_DEVICE"
if [ -z "$BOOT_FS_TYPE" ] ; then
  /bin/echo "ERROR: Filesystem type from boot device $BOOT_DEVICE empty"
  /bin/sleep infinity
elif [ "$BOOT_FS_TYPE" = "vfat" ] ; then
  /bin/mount -v -t vfat -o rw,flush,noatime,nodiratime,dmask=77,fmask=177,shortname=mixed $BOOT_DEVICE /boot || { /bin/echo "ERROR: Can't mount device: $BOOT_DEVICE"; /bin/sleep infinity; }
  /bin/echo "$BOOT_DEVICE mounted"
  /bin/echo "Running fsck.vfat on $BOOT_DEVCE"
  /usr/sbin/fsck.vfat $BOOT_DEVICE -y >/dev/null 2>&1
  /bin/echo "fsck.vfat done"
elif [ "$BOOT_FS_TYPE" = "ext4" ] ; then
  /bin/mount -v -t ext4 -o rw,noatime,discard $BOOT_DEVICE /boot || { /bin/echo "ERROR: Can't mount device: $BOOT_DEVICE"; /bin/sleep infinity; }
  /bin/echo "$BOOT_DEVICE mounted"
  fix_boot_permissions
elif [ "$BOOT_FS_TYPE" = "btrfs" ] ; then
  /bin/mount -v -t btrfs -o rw,noatime,nodiratime,degraded,discard=sync $BOOT_DEVICE /boot || { /bin/echo "ERROR: Can't mount device: $BOOT_DEVICE"; /bin/sleep infinity; }
  /bin/echo "$BOOT_DEVICE mounted"
  fix_boot_permissions
elif [ "$BOOT_FS_TYPE" = "xfs" ] ; then
  /bin/mount -v -t xfs -o rw,noatime,nodiratime,discard $BOOT_DEVICE /boot || { /bin/echo "ERROR: Can't mount device: $BOOT_DEVICE"; /bin/sleep infinity; }
  /bin/echo "$BOOT_DEVICE mounted"
  fix_boot_permissions
else
  /bin/echo "ERROR: $BOOT_FS_TYPE not supported"
  /bin/sleep infinity
fi

# Execute md5 check if not disabled
if [ ! -f /boot/config/system/md5check_disabled ] ; then
  /usr/bin/echo "Starting .md5 check from boot files"
  MD5_BAD="false"
  for file in $(/usr/bin/ls /boot/*.md5)
  do
    FILENAME=${file##*/}
    if [ ! -f /boot/${FILENAME%.*} ] ; then
      /usr/bin/echo "WARNING: File ${FILENAME%.*} not found, skipping"
      continue
    else
      MD5_GEN=$(/usr/bin/md5sum /boot/${FILENAME%.*} | /usr/bin/awk '{print $1}')
    fi
    MD5_SUM=$(/usr/bin/cat /boot/$FILENAME | /usr/bin/awk '{print $1}')
    if [ "$MD5_GEN" != "$MD5_SUM" ] ; then
      /usr/bin/echo "md5sum from ${FILENAME%.*} BAD"
      if [ ! -d /var/mos ] ; then
        /usr/bin/mkdir -p /var/mos
      fi
      /usr/bin/echo "${FILENAME%.*}" >> /var/mos/badfiles
      MD5_BAD="true"
    else
      /usr/bin/echo "md5sum from ${FILENAME%.*} OK"
    fi
  done
  
  if [ "$MD5_BAD" = "true" ] ; then
    /usr/bin/echo "ERROR: .md5 check returned errors, please check your installation"
    /usr/bin/echo "       Trying to continue with boot..."
  else
    /usr/bin/echo "Finished .md5 check sucessful"
  fi
fi

# Execute boot script
if [ -f /boot/optional/scripts/boot.sh ] ; then
  /bin/cp /boot/optional/scripts/boot.sh /tmp/boot.sh
  /bin/chmod +x /tmp/boot.sh
  /tmp/script.sh
  /bin/rm /tmp/script.sh
fi

# Create directories
/bin/mkdir -p /lib/firmware /lib/modules /var/overlay/lower/drivers
for dir in upper work; do
  for subdir in firmware modules; do
    /bin/mkdir -p /var/overlay/$dir/$subdir
  done
done

# Mount drivers
/bin/echo "Mounting drivers image"
/bin/mount -t squashfs -o loop /boot/drivers /var/overlay/lower/drivers

# Mount overlay directories
/bin/mount -t overlay overlay -o lowerdir=/var/overlay/lower/drivers/firmware,upperdir=/var/overlay/upper/firmware,workdir=/var/overlay/work/firmware /lib/firmware
/bin/mount -t overlay overlay -o lowerdir=/var/overlay/lower/drivers/modules,upperdir=/var/overlay/upper/modules,workdir=/var/overlay/work/modules /lib/modules

# Copy over modprobe.d files if found
MODPROBED_FILES="$(/bin/ls -1 /boot/optional/modprobe.d/* 2>/dev/null)"
if [ ! -z "$MODPROBED_FILES" ] ; then
  /bin/echo "Installing modprobe.d files"
  if [ ! -d /etc/modprobe.d ] ; then
    mkdir -p /etc/modprobe.d
  fi
  for modprobed_file in $MODPROBED_FILES
  do
    /bin/cp $modprobed_file /etc/modprobe.d
  done
fi

# Copy default profile.conf to boot device
if [ ! -f /boot/config/system/profile.conf ] ; then
  /bin/cp /etc/.mos.profile /boot/config/system/profile.conf
fi
# Symlink mos-profile.sh
if [ ! -f /etc/profile.d/mos-profile.sh ] ; then
  /bin/ln -sf /boot/config/system/profile.conf /etc/profile.d/mos-profile.sh
fi

# Install optional drivers
UNAME=$(/bin/uname -r)
DRIVERS=$(/bin/ls -1 /boot/optional/drivers/*/${UNAME}/*+mos_*.deb 2>/dev/null)

if [ ! -z "$DRIVERS" ] ; then
  for driver in $DRIVERS
  do
    /bin/echo "Installing driver: $(/bin/echo $driver | /usr/bin/rev | /usr/bin/cut -d '/' -f1 | /usr/bin/rev)"
    PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" /usr/bin/dpkg --install $driver >/dev/null
  done
  /sbin/depmod --all
  /sbin/ldconfig
fi

# Copy shadow and passwd from boot device if exist
if [ -f /boot/config/system/shadow ] ; then
  /bin/cp /boot/config/system/shadow /etc/shadow
fi
if [ -f /boot/config/system/passwd ] ; then
  /bin/cp /boot/config/system/passwd /etc/passwd
fi
if [ -f /boot/config/system/smbpasswd ] ; then
  /bin/cp /boot/config/system/smbpasswd /etc/samba/smbpasswd
fi

# Set timezone
TIMEZONE=$(/usr/bin/jq -r '.timezone' /boot/config/system.json)
/bin/ln -sf /usr/share/zoneinfo/$TIMEZONE /etc/localtime

# Cache json files into RAM
JSON_FILES=(
  "docker.json"
  "lxc.json" 
  "network.json"
  "pools.json"
  "shares.json"
  "system.json" 
  "vm.json"
)
for json in "${JSON_FILES[@]}"; do
  [ -f /boot/config/$json ] && /bin/cat /boot/config/$json > /dev/null
done

# Set ulimit before handing over to /sbin/init
ulimit -n 65536

# Set proxy as early as possible
for key in $(/usr/bin/jq -r 'keys[]' /boot/config/system/proxy.json 2>/dev/null) ; do
  value=$(/usr/bin/jq -r ".$key" /boot/config/system/proxy.json)
  if [ ! -z "$value" ] && [ "$value" != "null" ] ; then
    KEY_UPPER=$(/bin/echo "$key" | /usr/bin/tr '[:lower:]' '[:upper:]')
    export "$key=$value"
    export "$KEY_UPPER=$value"
    /bin/echo "$key=$value" >> /etc/environment
    /bin/echo "$KEY_UPPER=$value" >> /etc/environment
  fi
done

# Move system init to /lib/init/system-init
/bin/mv /init /lib/init/system-init

# Execute init
/bin/echo "Execute init"
exec /sbin/init
